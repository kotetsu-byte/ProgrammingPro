using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

#pragma warning disable CA1814 // Prefer jagged arrays over multidimensional

namespace ProgrammingPro.Server.Migrations
{
    /// <inheritdoc />
    public partial class init : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Courses",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    Name = table.Column<string>(type: "text", nullable: true),
                    Description = table.Column<string>(type: "text", nullable: true),
                    ImgName = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Courses", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    FirstName = table.Column<string>(type: "text", nullable: true),
                    LastName = table.Column<string>(type: "text", nullable: true),
                    Email = table.Column<int>(type: "integer", nullable: true),
                    UserName = table.Column<string>(type: "text", nullable: true),
                    PasswordHash = table.Column<string>(type: "text", nullable: true),
                    Role = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Lessons",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    Title = table.Column<string>(type: "text", nullable: true),
                    Text = table.Column<string>(type: "text", nullable: true),
                    CourseId = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Lessons", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Lessons_Courses_CourseId",
                        column: x => x.CourseId,
                        principalTable: "Courses",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Tests",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    Question = table.Column<string>(type: "text", nullable: true),
                    Answer1 = table.Column<string>(type: "text", nullable: true),
                    Answer2 = table.Column<string>(type: "text", nullable: true),
                    Answer3 = table.Column<string>(type: "text", nullable: true),
                    Answer4 = table.Column<string>(type: "text", nullable: true),
                    CorrectAnswer = table.Column<int>(type: "integer", nullable: true),
                    Points = table.Column<int>(type: "integer", nullable: true),
                    CourseId = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Tests", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Tests_Courses_CourseId",
                        column: x => x.CourseId,
                        principalTable: "Courses",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "UserCourses",
                columns: table => new
                {
                    UserId = table.Column<int>(type: "integer", nullable: false),
                    CourseId = table.Column<int>(type: "integer", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UserCourses", x => new { x.UserId, x.CourseId });
                    table.ForeignKey(
                        name: "FK_UserCourses_Courses_UserId",
                        column: x => x.UserId,
                        principalTable: "Courses",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_UserCourses_Users_CourseId",
                        column: x => x.CourseId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Docs",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    DocName = table.Column<string>(type: "text", nullable: true),
                    LessonId = table.Column<int>(type: "integer", nullable: true),
                    CourseId = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Docs", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Docs_Courses_CourseId",
                        column: x => x.CourseId,
                        principalTable: "Courses",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_Docs_Lessons_LessonId",
                        column: x => x.LessonId,
                        principalTable: "Lessons",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Homeworks",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    Title = table.Column<string>(type: "text", nullable: true),
                    Content = table.Column<string>(type: "text", nullable: true),
                    Deadline = table.Column<DateOnly>(type: "date", nullable: true),
                    LessonId = table.Column<int>(type: "integer", nullable: true),
                    CourseId = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Homeworks", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Homeworks_Courses_CourseId",
                        column: x => x.CourseId,
                        principalTable: "Courses",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_Homeworks_Lessons_LessonId",
                        column: x => x.LessonId,
                        principalTable: "Lessons",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Videos",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    VideoName = table.Column<string>(type: "text", nullable: true),
                    LessonId = table.Column<int>(type: "integer", nullable: true),
                    CourseId = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Videos", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Videos_Courses_CourseId",
                        column: x => x.CourseId,
                        principalTable: "Courses",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_Videos_Lessons_LessonId",
                        column: x => x.LessonId,
                        principalTable: "Lessons",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Materials",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    MaterialName = table.Column<string>(type: "text", nullable: true),
                    HomeworkId = table.Column<int>(type: "integer", nullable: true),
                    LessonId = table.Column<int>(type: "integer", nullable: true),
                    CourseId = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Materials", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Materials_Courses_CourseId",
                        column: x => x.CourseId,
                        principalTable: "Courses",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_Materials_Homeworks_HomeworkId",
                        column: x => x.HomeworkId,
                        principalTable: "Homeworks",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_Materials_Lessons_LessonId",
                        column: x => x.LessonId,
                        principalTable: "Lessons",
                        principalColumn: "Id");
                });

            migrationBuilder.InsertData(
                table: "Courses",
                columns: new[] { "Id", "Description", "ImgName", "Name" },
                values: new object[,]
                {
                    { 1, "C++ был разработан Бьёрном Страуструпом в подразделении Bell Labs компании AT&T в качестве дополнения к языку Cи. С++ добавил множество новых возможностей в язык Си. Его популярность была вызвана объектно-ориентированностью языка. Сейчас C++ широко используется для разработки программного обеспечения, являясь одним из самых популярных языков программирования. С его помощью создают операционные системы, разнообразные прикладные программы, драйверы устройств, игры и пр.", "", "C++" },
                    { 2, "C# — объектно-ориентированный язык программирования общего назначения. Разработан в 1998—2001 годах группой инженеров компании Microsoft под руководством Андерса Хейлсберга и Скотта Вильтаумота как язык разработки приложений для платформы Microsoft .NET Framework и .NET Core", "", "C#" },
                    { 3, "Java — строго типизированный объектно-ориентированный язык программирования общего назначения, разработанный компанией Sun Microsystems (в последующем приобретённой компанией Oracle). Разработка ведётся сообществом, организованным через Java Community Process; язык и основные реализующие его технологии распространяются по лицензии GPL. Права на торговую марку принадлежат корпорации Oracle.", "", "Java" },
                    { 4, "Python — высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим управлением памятью, ориентированный на повышение производительности разработчика, читаемости кода и его качества, а также на обеспечение переносимости написанных на нём программ. Язык является полностью объектно-ориентированным в том плане, что всё является объектами.", "", "Python" },
                    { 5, "Ruby — динамический, рефлективный, интерпретируемый высокоуровневый язык программирования. Язык обладает независимой от операционной системы реализацией многопоточности, сильной динамической типизацией, сборщиком мусора и многими другими возможностями. По особенностям синтаксиса он близок к языкам Perl и Eiffel, по объектно-ориентированному подходу — к Smalltalk.", "", "Ruby" },
                    { 6, "PHP — скриптовый язык общего назначения, интенсивно применяемый для разработки веб-приложений. В настоящее время поддерживается подавляющим большинством хостинг-провайдеров и является одним из лидеров среди языков, применяющихся для создания динамических веб-сайтов.", "", "PHP" }
                });

            migrationBuilder.InsertData(
                table: "Lessons",
                columns: new[] { "Id", "CourseId", "Text", "Title" },
                values: new object[,]
                {
                    { 1, 1, "Прежде чем мы продолжим знакомство с переменными в C++, давайте узнаем, значениями какого типа мы можем заполнять созданные нами переменные.\r\n\r\nВот список стандартных типов данных:\r\n\r\nint - это целый тип, который может хранить в себе только целые числа.\r\nfloat - данный тип является неточным. Он позволяет хранить не только целую часть, но, в отличии от типа int, и дробную.\r\ndouble - данный тип нечем не отличается от float, кроме более высокой точности (позволяет хранить больше чисел после запятой).\r\nchar - в данный тип данных можно записывать отдельные символы (абсолютно любые).\r\nbool - хранит в себе значения логического типа: “правду” - true, либо “ложь” - false. О данном типе мы подробно поговорим в уроке о логических выражениях.\r\nТеперь когда мы вооружились знаниями о возможных типах данных, можем переходить непосредственно к созданию переменных на языке C++!", "Переменные" },
                    { 2, 1, "Заголовочный файл <cmath> стандартной библиотеки C++ определяет набор математических функций. которые можно использовать в программах. Перечислю наиболее распространенные:\r\n\r\nabs(arg): вычисляет абсолютное значение arg. В отличие от большинства функций , abs() возвращает целочисленный тип, если arg является целым числом.\r\n\r\nceil(arg): вычисляет ближайшее целое число, большее или равное arg, и возвращает его в виде числа с плавающей точкой. Например, выражение std::ceil(2.5) возвращает 3.0, а std::ceil(-2.5) - -2.0. (дробная часть округляется до единицы)\r\n\r\nfloor(arg): вычисляет ближайшее целое число, меньшее или равное arg, и возвращает его в виде числа с плавающей точкой. Например, выражение std::floor(2.5) возвращает 2.0, а std::floor(-2.5) - число -3.0. (дробная часть округляется до нуля)\r\n\r\nexp(arg): вычисляет выражение earg.\r\n\r\nlog(arg): вычисляет натуральный логарифм (по основанию e) числа arg.\r\n\r\nlog10(arg): вычисляет логарифм по основанию 10 от arg.\r\n\r\npow(arg1, arg2): вычисляет значение arg1, возведенное в степень arg2, то есть arg1arg2. Числа arg1 и arg2 могут быть целочисленными или с плавающей запятой. Так, результат std::pow(2, 3) равен 8.0, а std::pow(4, 0,5) равно 2,0.\r\n\r\nsqrt(arg): вычисляет квадратный корень из arg.\r\n\r\nround(arg), lround (arg) и llround (arg) округляют число до ближайщего целого. Разница между ними состоит в типа возвращаемого результата: round() возвращает число с плавающей точкой, lround (arg) - число long, а llround (arg) - long long.\r\n\r\nПоловинные значения округляются до нуля: std::lround(0.5) возвращает 1L, тогда как std::round(-1.5f) возвращает -2.0f.\r\n\r\nsin(arg): вычисляет синус угла, при этом arg представляет значение в радианах.\r\n\r\ncod(arg): вычисляет косинус угла.\r\n\r\ntan(arg): вычисляет тангенс угла.\r\n\r\nisinf(arg): возвращает true, если аргумент представляет +-бесконечность.\r\n\r\nisnan(arg): возвращает true, если аргумент представляет NaN.", "Математические операции" },
                    { 3, 1, "В языке программирования C++ есть следующие операции сравнения:\r\n\r\n==\r\n\r\nОперация \"равно\". Возвращает true, если оба операнда равны, и false, если они не равны. >\r\n\r\nОперация \"больше чем\". Возвращает true, если первый операнд больше второго, и false, если первый операнд меньше второго. <\r\n\r\nОперация \"меньше чем\". Возвращает true, если первый операнд меньше второго, и false, если первый операнд больше второго. <=\r\n\r\nОперация \"меньше или равно\". Возвращает true, если первый операнд меньше или равен второму, и false, если первый операнд больше второго. >=\r\n\r\nОперация \"больше или равно\". Возвращает true, если первый операнд больше или равен второму, и false, если первый операнд меньше второго. !=\r\n\r\nОперация \"не равно\". Возвращает true, если первый операнд не равен второму, и false, если оба операнда равны.", "Логические операции" },
                    { 4, 1, "В объявлении массива C++ размер массива указывается после имени переменной, а не после имени типа, как в других языках. В следующем примере объявляется массив из 1000 двойных размеров, выделенных в стеке. Число элементов должно быть предоставлено в виде целочисленного литерала или в качестве константного выражения. Это связано с тем, что компилятор должен знать, сколько пространства стека следует выделить; он не может использовать значение, вычисляемое во время выполнения. Каждому элементу в массиве присваивается значение по умолчанию 0. Если вы не назначаете значение по умолчанию, каждый элемент изначально содержит все случайные значения в этом расположении памяти.", "Массивы" },
                    { 5, 1, "Функции — это блоки кода, выполняющие определенные операции. Если требуется, функция может определять входные параметры, позволяющие вызывающим объектам передавать ей аргументы. При необходимости функция также может возвращать значение как выходное. Функции полезны для инкапсуляции основных операций в едином блоке, который может многократно использоваться. В идеальном случае имя этого блока должно четко описывать назначение функции. Следующая функция принимает два целых числа из вызывающего средства и возвращает их сумму; a и b — это параметры типа int. Функция может вызываться или вызываться из любого количества мест в программе. Значения, передаваемые функции, являются аргументами, типы которых должны быть совместимы с типами параметров в определении функции.", "Функции" },
                    { 6, 1, "Объект в C++ — это структура данных, которая является экземпляром класса.\r\n\r\nКогда класс определяется, память не выделяется, но при создании экземпляра (объявлении объекта) память выделяется для хранения данных и выполнения необходимых функций.\r\n\r\nОбъекты позволяют манипулировать данными внутри класса.", "Объекты" },
                    { 7, 2, "Для хранения данных в программе применяются переменные. Переменная представляет именнованную область памяти, в которой хранится значение определенного типа. Переменная имеет тип, имя и значение. Тип определяет, какого рода информацию может хранить переменная.\r\n\r\nПеред использованием любую переменную надо определить. Вначале идет тип переменной, потом ее имя. В качестве имени переменной может выступать любое произвольное название, которое удовлетворяет следующим требованиям:\r\n\r\nимя может содержать любые цифры, буквы и символ подчеркивания, при этом первый символ в имени должен быть буквой или символом подчеркивания\r\n\r\nв имени не должно быть знаков пунктуации и пробелов\r\n\r\nимя не может быть ключевым словом языка C#. Таких слов не так много, и при работе в Visual Studio среда разработки подсвечивает ключевые слова синим цветом.\r\n\r\nХотя имя переменой может быть любым, но следует давать переменным описательные имена, которые будут говорить об их предназначении.", "Переменные" },
                    { 8, 2, "Следующие операторы выполняют арифметические операции с операндами числовых типов:\r\n\r\nунарные — ++ (приращение), -- (уменьшение), + (плюс) и - (минус);\r\nбинарные — * (умножение), / (деление), % (остаток от деления), + (сложение) и - (вычитание).\r\nЭти операторы поддерживаются всеми целочисленными типами и типами с плавающей запятой.\r\n\r\nВ случае целочисленных типов эти операторы (за исключением операторов ++ и --) определяются для типов int, uint, longи ulong. Если операнды принадлежат к другим целочисленным типам (sbyte, byte, short, ushort или char), их значения преобразуются в тип int, который также является типом результата операции. Если операнды принадлежат к разным целочисленным типам или типам с плавающей запятой, их значения преобразуются в ближайший содержащий тип, если такой тип существует. Дополнительные сведения см. в разделе Числовые повышения уровня в статье Спецификации языка C#. Операторы ++ и -- определяются для всех целочисленных числовых типов и числовых типов с плавающей запятой, а также типа char. Тип результата выражения сложного назначения является типом левого операнда.", "Математические операции" },
                    { 9, 2, "Логические логические операторы выполняют логические операции с логическими операндами. Операторы включают унарное логическое отрицание (!), двоичное логическое И (), OR (&|) и монопольное ИЛИ (^), а также двоичный условный логический и () и OR (&&||).\r\n\r\nУнарный ! (логическое отрицание) оператор.\r\nБинарные & (логическое И), | (логическое ИЛИ), а также ^ (логическое исключающее ИЛИ) операторы. Эти операторы всегда обрабатывают оба операнда.\r\nБинарные && (условное логическое И) и || (условное логическое ИЛИ) операторы. Эти операторы вычисляют правый операнд, только если это необходимо.\r\nДля операндов целочисленных типов операторы &, | и ^ выполняют побитовые логические операции. Дополнительные сведения см. в разделе Побитовые операторы и операторы сдвига.", "Логические операции" },
                    { 10, 2, "Массив имеет следующие свойства:\r\n\r\nМассив может быть одномерным, многомерным или многомерным.\r\nЧисло измерений задается при объявлении переменной массива. Длина каждого измерения устанавливается при создании экземпляра массива. Эти значения нельзя изменить во время существования экземпляра.\r\nМассив массивов является массивом массивов, и каждый массив элементов имеет значение nullпо умолчанию.\r\nМассивы индексируются от нуля: массив с n элементами индексируется от 0 до n-1.\r\nЭлементы массива могут иметь любой тип, в том числе тип массива.\r\nТипы массивов — это ссылочные типы, производные от абстрактного базового типа Array. Все массивы реализуют IList и IEnumerable. Для итерации по массиву можно использовать оператор foreach. Одномерные массивы также реализуют IList<T> и IEnumerable<T>.", "Массивы" },
                    { 11, 2, "Функции — это специальные блоки кода, которые можно вызывать из других частей программы. Это дает возможность повторно использовать уже написанный код, а также более организовано структурировать программу.\r\nДля вызова функции в C# необходимо использовать ее имя, после которого следуют скобки. В скобках указываются аргументы функции, если они есть. Например: public int Add (int x, int y) {return x + y;} public void Main () {int result = Add (2, 3);}.", "Функции" },
                    { 12, 2, "Объект в языке C# — это реализация класса в виде некоторой сущности.\r\n\r\nАналог класса в реальной жизни — это чертёж здания или автомобиля, то есть некоторый шаблон.\r\n\r\nВыделяют три основных принципа объектно-ориентированного программирования (ООП):\r\n\r\nИнкапсуляция. Предполагает сокрытие деталей реализации и связывание данных и методов для их обработки в одном месте.\r\n\r\nНаследование. Один класс может наследовать функции и данные другого класса.\r\n\r\nПолиморфизм. Возможность обработки данных разных типов одной и той же функцией.", "Объекты" },
                    { 13, 3, "Переменная в Java — это контейнер,  в котором может храниться некоторое значение данных для дальнейшего использования в программе. По сути переменная — это минимальная неделимая единица Java-приложения.\r\n\r\nПеременные в Java бывают двух видов: предназначенные для для маленьких данных (примитивные переменные) и для более сложных, тяжёлых (ссылочные переменные).\r\n\r\nСегодня мы рассмотрим первый случай, когда переменные хранят именно само значение данных. Такие переменные называют примитивными.", "Переменные" },
                    { 14, 3, "У оператора деления — своя специфика. Например, результатом выражения 10 / 3 будет тройка. Почему так? Когда оператор применяется к целым числам, остаток от деления отбрасывается, чтобы результатом тоже было целое число. Получить остаток от деления позволяет другой оператор — %. Например, остатком от деления 10 на 3 будет единица. Её и вернёт оператор %.\r\nМинус в Java тоже имеет двойной смысл: когда этот оператор применяют к двум операндам, минус называют бинарным. В этом случае речь идёт о вычитании. Например, 10 - 3 = 7. Когда же минус относится только к одному операнду, его называют унарным — он указывает, что значение операнда будет отрицательным: x = -1.\r\n\r\nБольшую часть математических операций в Java разработчики выполняют с помощью библиотек. Они содержат готовые функции для вычисления синусов, косинусов, возведения в степень и более сложных арифметических действий.", "Математические операции" },
                    { 15, 3, "В Java доступны следующие логические операции: \r\nЛогическое отрицание, оно же NOT или инверсия. В Java обозначается символом “!” перед операндом. Применяется к одному операнду.\r\nЛогическое и, оно же AND или конъюнкция. Обозначается символом “&” между двумя операндами, к которым применяется.\r\nЛогическое или в Java, оно же — OR, оно же — дизъюнкция. В Java обозначается символом “|” между двумя операндами.\r\nИсключающее или, XOR, строгая дизъюнкция. В Java обозначается символом “^” между двумя операндами.\r\nВ Java к логическим операторам можно отнести условное или, обозначаемое как ||, а также условное и — &&.", "Логические операции" },
                    { 16, 3, "Массив — это структура данных, в которой хранятся элементы одного типа. Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку). Доступ к конкретной ячейке осуществляется через её номер. Номер элемента в массиве также называют индексом. \r\n\r\nВ случае с Java массив однороден, то есть во всех его ячейках будут храниться элементы одного типа. Так, массив целых чисел содержит только целые числа (например, типа int), массив строк — только строки, массив из элементов созданного нами класса Dog будет содержать только объекты Dog. То есть в Java мы не можем поместить в первую ячейку массива целое число, во вторую String, а в третью — “собаку”. ", "Массивы" },
                    { 17, 3, "Функция в Java — это набор инструкций, который может быть вызван по имени.\r\n\r\nФункции могут принимать параметры (аргументы) и возвращать результат. В Java функции называются методами и объявляются внутри классов.\r\n\r\nДля создания функции в Java следует выполнить следующие шаги:\r\n\r\nОпределить имя функции.\r\n\r\nОпределить тип возвращаемого значения.\r\n\r\nОпределить параметры (если есть).\r\n\r\nНаписать тело функции.\r\n\r\nНазвания функций должны быть говорящими и отражать их назначение. Старайтесь делать функции небольшими и выполняющими одну конкретную задачу. Используйте параметры для передачи данных в функцию и возвращаемые значения для получения результатов.", "Функции" },
                    { 18, 3, "Объект – это конкретный экземпляр класса. Объекты создаются с использованием оператора new и инициализируются с помощью конструктора класса. Вот пример создания объекта типа Person: Person person1 = new Person (); person1.name = \"Анна\"; person1.age = 30; person1.sayHello (); // Вывод: Привет, меня зовут Анна и мне 30 лет! Каждый объект имеет свои собственные значения полей, независимые от других объектов того же класса.", "Объекты" },
                    { 19, 4, "Переменная — это область памяти компьютера, у которой есть имя. Структурно она состоит из трёх частей:\r\n\r\nИмя, или идентификатор, — это название, придуманное программистом, чтобы обращаться к переменной. В примерах выше это x, name и coin_flipping_result.\r\nЗначение — это информация, которая хранится в памяти компьютера и с которой работает программа. В примерах выше это 4, 'Виктория' и ['орёл', 'решка', 'решка', 'орёл']. Они всегда принадлежат к какому-либо типу данных.\r\nАдрес — это номер ячейки памяти, в которой хранится значение переменной.\r\nПриведём наглядную аналогию. Представьте большой производственный склад, заполненный стеллажами, на которых стоят коробки. Склад — это общая память компьютера. Допустим, на третьем стеллаже, на второй полке, в шестой ячейке стоит какая-нибудь коробка. Если в неё что-нибудь положить и наклеить этикетку с названием — коробка будет переменной. То, что в ней лежит, — это её значение. Третий стеллаж, вторая полка, пятая ячейка — её адрес, а этикетка — её имя.", "Переменные" },
                    { 20, 4, "Язык Python, благодаря наличию огромного количества библиотек для решения разного рода вычислительных задач, сегодня является конкурентом таким пакетам как Matlab и Octave. Запущенный в интерактивном режиме, он, фактически, превращается в мощный калькулятор. В этом уроке речь пойдет об арифметических операциях, доступных в данном языке.\r\n\r\nАрифметические операции будем изучать применительно к числам, причем работу с комплексными числами разберем отдельно. Также, кратко остановимся на битовых операциях, представлении чисел в разных системах исчисления и коснемся библиотеки math.\r\n\r\nКак было сказано в предыдущем уроке, посвященном типами и модели данных Python, в этом языке существует три встроенных числовых типа данных:\r\n\r\nцелые числа (int);\r\nвещественные числа (float);\r\nкомплексные числа (complex).\r\nЕсли в качестве операндов некоторого арифметического выражения используются только целые числа, то результат тоже будет целое число. Исключением является операция деления, результатом которой является вещественное число. При совместном использовании целочисленных и вещественных переменных, результат будет вещественным.", "Математические операции" },
                    { 21, 4, "Простейшие условные выражения представляют операции сравнения, которые сравнивают два значения. Python поддерживает следующие операции сравнения:\r\n\r\n==\r\n\r\nВозвращает True, если оба операнда равны. Иначе возвращает False.\r\n\r\n!=\r\n\r\nВозвращает True, если оба операнда НЕ равны. Иначе возвращает False.\r\n\r\n> (больше чем)\r\n\r\nВозвращает True, если первый операнд больше второго.\r\n\r\n< (меньше чем)\r\n\r\nВозвращает True, если первый операнд меньше второго.\r\n\r\n>= (больше или равно)\r\n\r\nВозвращает True, если первый операнд больше или равен второму.\r\n\r\n<= (меньше или равно)\r\n\r\nВозвращает True, если первый операнд меньше или равен второму.", "Логические операции" },
                    { 22, 4, "В языке Python как таковых массивов нет. Вместо этого для хранения группы однотипных (но и не только однотипных) объектов используют списки - объекты типа list. Отличие списков от массивов заключается в том, что список - это динамическая структура, размер которого можно изменять во время выполнения программы (удалять, добавлять элементы) не задумываясь над операциями по управлению памятью (это делает транслятор).\r\nВ дальнейшем, разбирая работу со списками, будем использовать слово \"массив\", так как чаще всего списки используются именно в роли массива (хранят однотипные данные).", "Массивы" },
                    { 23, 4, "Функция в программировании представляет собой обособленный участок кода, который можно вызывать, обратившись к нему по имени, которым он был назван. При вызове происходит выполнение команд тела функции.\r\n\r\nФункции можно сравнить с небольшими программками, которые сами по себе, то есть автономно, не исполняются, а встраиваются в обычную программу. Нередко их так и называют - подпрограммы. Других ключевых отличий функций от программ нет. Функции также при необходимости могут получать и возвращать данные. Только обычно они их получают не с ввода, а из вызывающей программы. Сюда же они возвращают результат свой работы.\r\n\r\nСуществует множество встроенных в язык программирования функций. С некоторыми такими в Python вы уже сталкивались. Это print(), input(), int(), float(), str(), type(). Код их тела нам не виден, он где-то \"спрятан внутри языка\". Нам же предоставляется только интерфейс - имя функции.\r\n\r\nС другой стороны, программист может определять свои функции. Их называют пользовательскими. В данном случае под \"пользователем\" понимают программиста, а не того, кто использует программу.", "Функции" },
                    { 24, 4, "Объект — это экземпляр класса. Класс можно сравнить с чертежом, по которому создаются объекты.\r\nPython соответствует принципам объектно-ориентированного программирования. В python всё является объектами - и строки, и списки, и словари, и всё остальное.\r\nНо возможности ООП в python этим не ограничены. Программист может написать свой тип данных (класс), определить в нём свои методы.", "Объекты" },
                    { 25, 5, "В Ruby есть четыре типа переменных:\r\n\r\nЛокальные переменные. Определяются в методе или блоке и доступны только внутри этого метода или блока.\r\n\r\nInstance-переменные. Связаны с конкретным экземпляром класса и доступны из любого метода внутри этого экземпляра.\r\n\r\nClass-переменные. Связаны с конкретным классом и доступны для всех экземпляров этого класса.\r\n\r\nGlobal-переменные. Доступны из любого места в программе Ruby.\r\n\r\nДля объявления переменных используется строчная буква или подчеркивание, за которыми следует комбинация букв, цифр или подчеркиваний. Для присвоения значений переменным используется оператор присваивания (=).", "Переменные" },
                    { 26, 5, "Ruby поддерживает богатый набор операторов, как и следовало ожидать от современного языка. Большинство операторов — это фактически вызовы методов. Например, a + b интерпретируется как. + (B), где метод + в объекте, на который ссылается переменная a, вызывается с аргументом b .\r\n\r\nДля каждого оператора (+ — * /% ** & | ^ << >> && ||) существует соответствующая форма оператора сокращенного присваивания (+ = — = и т. д.).", "Математические операции" },
                    { 27, 5, "Логический тип в Ruby представлен привычными значениями true и false, а также набором операторов:\r\n\r\n&& (и),\r\n\r\n== (равно),\r\n\r\n|| (или),\r\n\r\n! (не).\r\n\r\nВ отличие от многих других языков сравнение с логическим значением в Ruby строгое, то есть true и false равны только самим себе.\r\n\r\nВ Ruby только nil и false рассматриваются как falsey, все остальные значения в логических выражениях приводятся к true.", "Логические операции" },
                    { 28, 5, "Массив — упорядоченная коллекция произвольных объектов с целочисленной индексацией. Нумерация элементов массива начинается с 0, как в языках Си или Java. Отрицательный индекс предполагает отсчет с конца массива, то есть индексу -1 соответствует последний элемент массива, -2 — предпоследний, и так далее.", "Массивы" },
                    { 29, 5, "В Ruby функциональное программирование поддерживается благодаря конструкции языка, которая включает выражения, блоки и возможность строить объекты с любым поведением.\r\n\r\nОсновные принципы функционального программирования:\r\n\r\nПрограмма в функциональном стиле — это сложное выражение, в котором функции применяют функции.\r\n\r\nФункции должны быть чистыми: код должен быть построен так, чтобы функция, применённая к одним и тем же аргументам, возвращала одно и то же значение.\r\n\r\nПеременные, объекты и состояния не изменяются. Функция может сконструировать и вернуть новый объект, но не станет изменять переданные ей аргументы.", "Функции" },
                    { 30, 5, "В Ruby есть много разных видов объектов, например:\r\n\r\nстроки (String),\r\n\r\nцелые числа (Fixnum),\r\n\r\nмассивы (Array).\r\n\r\nУ каждого из этих объектов есть свой тип, который называется классом.\r\n\r\nКласс — это описание типа объектов, которые можно создавать.\r\n\r\nКонкретный объект какого-то класса в программировании называется экземпляр класса.", "Объекты" },
                    { 31, 6, "По умолчанию переменные присваиваются по значению. То есть, когда переменной присваивают выражение, значение оригинального выражения копируется в эту переменную. Это означает, например, что после присваивания одной переменной значения другой, изменение одной из переменных не влияет на другую. Дополнительную информацию об этом способе присваивания смотрите в разделе «Выражения».\r\n\r\nPHP также предлагает другой способ присваивания значений переменным: присваивание по ссылке. Это означает, что новая переменная просто ссылается (иначе говоря, «становится псевдонимом» или «указывает») на оригинальную переменную. Изменения в новой переменной отражаются на оригинале, и наоборот.\r\n\r\nДля присваивания по ссылке просто добавьте амперсанд & к началу имени присваиваемой (исходной) переменной. Например, следующий фрагмент кода дважды выводит «Меня зовут Боб»:", "Переменные" },
                    { 32, 6, "Предположим, что переменная A содержит 10, а переменная B содержит 20. Тогда приведенные ниже арифметические операторы выполняют следующие операции:\r\n\r\nоператор сложения (+) складывает два операнда (A + B; результат: 30);\r\nоператор вычитания (-) вычитает второй операнд из первого (A-B; результат: -10);\r\nоператор умножения (*) умножает один операнд на другой (A * B; результат: 200);\r\nоператор деления (/) делит делимое на делитель (B / A; результат: 2);\r\nоператор модуля (%) выводит остаток после целочисленного деления (B % A; результат: 0);\r\nоператор инкремента (++) увеличивает целочисленное значение на единицу (A++; результат: 11);\r\nоператор декремента (- -) уменьшает целочисленное значение на единицу (A- -; результат: 9).", "Математические операции" },
                    { 33, 6, "Операции сравнения, как правило, применяются в условных конструкциях, когда надо сравнивать два значения, и в зависимости от результата сравнения выполнить некоторые действия. Имеются следующие операции сравнения.\r\n\r\n==\r\n\r\nОператор равенства сравнивает два значения, и если они равны, возвращает true, иначе возвращает false: $a == 5\r\n===\r\n\r\nОператор тождественности также сравнивает два значения, и если они равны, возвращает true, иначе возвращает false: $a === 5\r\n!=\r\n\r\nСравнивает два значения, и если они не равны, возвращает true, иначе возвращает false: $a != 5\r\n!==\r\n\r\nСравнивает два значения, и если они не равны, возвращает true, иначе возвращает false: $a !== 5\r\n>\r\n\r\nСравнивает два значения, и если первое больше второго, то возвращает true, иначе возвращает false: $a > 5\r\n<\r\n\r\nСравнивает два значения, и если первое меньше второго, то возвращает true, иначе возвращает false: $a < 5\r\n>=\r\n\r\nСравнивает два значения, и если первое больше или равно второму, то возвращает true, иначе возвращает false: $a >= 5\r\n<=\r\n\r\nСравнивает два значения, и если первое меньше или равно второму, то возвращает true, иначе возвращает false: $a <= 5", "Логические операции" },
                    { 34, 6, "Массив в PHP — это упорядоченная структура данных, которая связывает значения и ключи. Этот тип данных оптимизирован для разных целей, поэтому с ним работают как с массивом, списком (вектором), хеш-таблицей (реализацией карты), словарём, коллекцией, стеком, очередью и, возможно, чем-то ещё. Поскольку значениями массива бывают другие массивы, также доступны деревья и многомерные массивы.\r\n\r\nОбъяснение этих структур данных выходит за рамки этого руководства, но как минимум один пример будет приведён для каждой из них. За дополнительной информацией обращаются к большому объему литературы по этой обширной теме.", "Массивы" },
                    { 35, 6, "Функция в PHP — это автономный блок кода, который выполняет определённую задачу.\r\n\r\nВ PHP есть множество встроенных функций, которые можно вызывать непосредственно в скриптах для выполнения конкретной задачи. Например, gettype(), print_r(), var_dump и т. д.\r\n\r\nТакже PHP позволяет определять свои собственные функции. Это способ создания повторно используемых пакетов кода, которые выполняют определённые задачи и могут храниться и поддерживаться отдельно от основной программы.\r\n\r\nПреимущества использования функций:\r\n\r\nСокращают повторение кода в программе.\r\n\r\nУпрощают обслуживание кода.\r\n\r\nУпрощают устранение ошибок.\r\n\r\nМогут быть повторно использованы в другом приложении.", "Функции" },
                    { 36, 6, "При создании программы на PHP и отдельных ее блоков нам вполне может хватить той функциональности, которую представляют функции. Однако PHP имеет и другие возможности по созданию программ, которые представляет объектно-ориентированное программирование. В ряде случаев программы, использующие ООП, проще в понимании, их легче поддерживать и изменять.\r\n\r\nКлючевыми понятиями парадигмы ООП являются понятия \"класс\" и \"объект\". Описанием объекта является класс, а объект представляет экземпляр этого класса. Можно провести следующую аналогию: например, у каждого человека есть имя, определенный возраст, вес, какие-то другие параметры. То есть некоторый шаблон, который содержит набор параметров человека - этот шаблон можно назвать классом. А реально же существующий человек с конкретным именем, возрастом, весом и т.д. является объектом или экземпляром этого класса.", "Объекты" }
                });

            migrationBuilder.InsertData(
                table: "Tests",
                columns: new[] { "Id", "Answer1", "Answer2", "Answer3", "Answer4", "CorrectAnswer", "CourseId", "Points", "Question" },
                values: new object[,]
                {
                    { 1, "любой тип данных, определяемый пользователем", "тип данных, определяемый пользователем и сочетающий в себе данные и функции их обработки", "структура, для которой в программе имеются функции работы с нею", "нет правильного ответа", 1, 1, 20, "Класс - это" },
                    { 2, "только переменные, объявленные как private", "только функции, объявленные как private", "только переменные и функции, объявленные как private", "как переменные, так и функции, могут быть объявлены как private и как public", 4, 1, 20, "Членами класса могут быть" },
                    { 3, "метод, имя которого совпадает с именем класса и который вызывается автоматически при объявлении класса (до создания объекта класса)", "метод, имя которого необязательно совпадает с именем класса и который вызывается при создании объекта класса", "метод, имя которого совпадает с именем класса и который вызывается автоматически при создании объекта класса", "метод, имя которого совпадает с именем класса и который необходимо явно вызывать из головной программы при объявлении объекта класса", 3, 1, 20, "Что называется конструктором?" },
                    { 4, "переменная, содержащая указатель на класс", "экземпляр класса", "класс, который содержит в себе данные и методы их обработки", "нет правильного ответа", 2, 1, 20, "Объект - это" },
                    { 5, "метод, который уничтожает объект", "метод, который удаляет объект", "метод, который освобождает память, занимаемую объектом", "системная функция, которая освобождает память, занимаемую объектом", 3, 1, 20, "Что называется деструктором" },
                    { 6, "это механизм, посредством которого производный класс получает элементы родительского и может дополнять либо изменять их свойства и методы", "это механизм переопределения методов базового класса", "это механизм, посредством которого производный класс получает все поля базового класса", "это механизм, посредством которого производный класс получает элементы родительского, может их дополнить, но не может переопределить", 1, 1, 20, "Что называется наследованием?" },
                    { 7, "class MoreDetails:: Details;", "class MoreDetails: public class Details;", "class MoreDetails: public Details;", "class MoreDetails: class(Details);", 3, 1, 20, "Выберите правильное объявление производного класса" },
                    { 8, "ключами доступа: private, public, protected в теле производного класса", "только ключом доступа protected в заголовке объявления производного класса", "ключами доступа: private, public, protected в заголовке объявления производного класса", "ключами доступа: private, public, protected в теле базового класса", 3, 1, 20, "Возможность и способ обращения производного класса к элементам базового определяется" },
                    { 9, "функция другого класса, среди аргументов которой есть элементы данного класса", "функция, объявленная в классе с атрибутом friend, но не являющаяся членом класса;", "функция, являющаяся членом класса и объявленная с атрибутом friend;", "функция, которая в другом классе объявлена как дружественная данному", 2, 1, 20, "Дружественная функция - это" },
                    { 10, "определение функции, в которой типу обрабатываемых данных присвоено условное обозначение", "прототип функции, в котором вместо имен параметров указан условный тип", "определение функции, в котором указаны возможные варианты типов обрабатываемых параметров", "определение функции, в котором в прототипе указан условный тип, а в определении указаны варианты типов обрабатываемых параметров", 1, 1, 20, "Шаблон функции - это..." },
                    { 11, "имя_класса, ключевое слово operation, символ операции", "имя_класса, ключевое слово operator, символ операции, в круглых скобках могут быть указаны аргументы", "имя_класса, ключевое слово operator, список аргументов", "имя_класса, два двоеточия, ключевое слово operator, символ операции", 2, 1, 20, "Переопределение операций имеет вид:" },
                    { 12, "при обращении через имя объекта – точка, при обращении через указатель – операция «->»", "при обращении через имя объекта – два двоеточия, при обращении через указатель – операция «точка»", "при обращении через имя объекта – точка, при обращении через указатель – два двоеточия", "при обращении через имя объекта – два двоеточия, при обращении через указатель – операция «->»", 1, 1, 20, "Для доступа к элементам объекта используются:" },
                    { 13, "средство, позволяющее в одном классе использовать методы с одинаковыми именами;", "средство, позволяющее в одном классе использовать методы с разными именами для выполнения одинаковых действий\r\n\r\n", "средство, позволяющее перегружать функции для работы с разными типами или разным количеством аргументов", "средство, позволяющее использовать одно имя для обозначения действий, общих для родственных классов", 4, 1, 20, "Полиморфизм – это :" },
                    { 14, "перегрузки функций, наследования методов, шаблонов;", "наследования методов, виртуальных функций, шаблонов", "перегрузки функций, виртуальных функций, шаблонов", "перегрузки функций, наследования, виртуальных функций.", 3, 1, 20, "Полиморфизм реализован через механизмы:" },
                    { 15, "функции базового класса, которые могут быть переопределены в производном классе", "функции базового класса, которые не используются в производном классе;", "функции базового класса, которые не могут быть переопределены в базовом классе;", "функции производного класса, переопределенные относительно базового класса", 1, 1, 20, "Виртуальными называются функции:" },
                    { 16, "через механизмы перегрузки (функций и операций) и шаблоны;", "через механизмы перегрузки (функций и операций), виртуальные функции и шаблоны", "через виртуальные функции и шаблоны;", "через механизмы перегрузки (функций и операций) и виртуальные функции", 2, 1, 20, "Полиморфизм в объектно-ориентированном программировании реализуется:" },
                    { 17, "для использования классов, переменных и функций из других модулей программы без использования заголовочных файлов", "для заключения в группу объявлений классов, переменных и функций в отдельный контекст со своим именем", "для заключения в группу объявлений классов, переменных и функций для использования только в текущем модуле", "нет правильного ответа", 2, 1, 20, "Для чего предназначен оператор namespace:" },
                    { 18, "наладчик", "доводчик", "отладчик", "все вышеперечисленные", 3, 1, 20, "Какой из компонентов может входить в интегрированную среду программирования:" },
                    { 19, "enum { a, b = 3, c = 4, 3 };", "enum { a, b, 3, 4 };", "enum {a, b = 3, c, d }; +", "все вышеперечисленные", 3, 1, 20, "Какой из наборов перечисляемых значений записан правильно:" },
                    { 20, "различие заключается в методе поиска препроцессором включаемого файла", "в различии использования заголовочных и исходных файлов", "нет различий", "оба варианты верны", 0, 1, 0, "В чем различие использования следующих выражений #include <…> и #include «…»:" },
                    { 21, "Область динамической памяти", "Именованная область памяти", "Куча переменных", "Нет правильного ответа", 1, 2, 20, "Что такое Куча:" },
                    { 22, "for, while", "for, while, do while, foreach", "for, while, do while", "Нет правильного ответа", 2, 2, 20, "Какие циклы существуют в языке C#:" },
                    { 23, "Устраивает «войну» между программами", "Обозначает что переменная имеет явный тип данных", "Обозначает что переменная без явного типа данных", "Нет правильного ответа", 3, 2, 20, "Что обозначает ключевое слово var:" },
                    { 24, "int, char, bool, float, double", "int, char, bool, string", "Оба варианта верны", "Нет верного ответа", 3, 2, 20, "Какие типы переменных существуют:" },
                    { 25, "Глобальная переменная", "Переменная которая может быть изменена в любое время", "Переменная значение которой нельзя изменить", "Нет верного ответа", 3, 2, 20, "Что такое константа:" },
                    { 26, "$x = 10;", "char symbol = ‘A’;", "x = 0;", "Нет верного ответа", 2, 2, 20, "Где правильно создана переменная:" },
                    { 27, "end", "out", "return", "Нет верного ответа", 3, 2, 20, "Какой оператор возвращает значение из метода:" },
                    { 28, "Continue пропускает итерацию, break выходит из цикла", "Break используется в Switch case, а continue в циклах", "Continue работает только в циклах, break дополнительно в методах", "Нет верного ответа", 1, 2, 20, "В чем отличие между break и continue:" },
                    { 29, "Цикл, Форич, Двойной цикл, Многократный", "Большие и маленькие", "for, while, do-while, foreach", "Нет верного ответа", 3, 2, 20, "Какие бывают циклы:" },
                    { 30, "Работает с файлами", "Работает с исключениями", "Работает с классами", "Нет верного ответа", 2, 2, 20, "Что делает try-catch:" },
                    { 31, "Циклы нужны для многократного выполнения кода", "Циклы нужны для многократного запуска программы", "Циклы нужны для многократного размещения данных", "Нет верного ответа", 1, 2, 20, "Что такое цикл и для чего они нужны:" },
                    { 32, "Для создания веб сайтов", "Для создания программ под ПК", "Оба варианта верны", "Нет верного ответа", 3, 2, 20, "Для чего можно использовать язык C#:" },
                    { 33, "Одномерные и многомерные", "Резиновые и статичные", "Сложные и простые", "Нет верного ответа", 1, 2, 20, "Какие бывают массивы:" },
                    { 34, "Знаковое 64-бит целое", "Знаковое 8-бит целое", "Знаковое 32-бит целое", "Нет верного ответа", 3, 2, 20, "Какой тип переменной используется в коде: int a = 5:" },
                    { 35, "Набор однотипных данных, которые располагаются в памяти последовательно друг за другом", "Набор данных типа int (32-бит целое)", "Набор текстовых значений в формате Unicode, которые расположены в случайном порядке", "Нет верного ответа", 1, 2, 20, "Что такое массив:" },
                    { 36, "Возвращает процент от суммы", "Возвращает остаток от деления", "Возвращает тригонометрическую функцию", "Нет верного ответа", 2, 2, 20, "Что делает оператор «%»:" },
                    { 37, "Прямой оператор", "Вопросительный", "Тернарный оператор", "Нет верного ответа", 3, 2, 20, "Как называется оператор «?:»:" },
                    { 38, "Напишет Hello, World!", "Напишет на новой строчке Hello, World!", "Удалит все значения с Hello, World!", "Нет верного ответа", 2, 2, 20, "Что сделает программа выполнив следующий код: Console.WriteLine(«Hello, World!»);" },
                    { 39, "Чтобы устанавливать условия пользователю", "Для оптимизации программы", "Для ветвления программы", "Нет верного ответа", 3, 2, 20, "Для чего нужны условные операторы:" },
                    { 40, "!=", "++", "—-", "Нет верного ответа", 2, 2, 20, "Как сделать инкрементацию числа:" },
                    { 41, "", "", "", "", 0, 3, 0, "" },
                    { 42, "", "", "", "", 0, 3, 0, "" },
                    { 43, "", "", "", "", 0, 3, 0, "" },
                    { 44, "", "", "", "", 0, 3, 0, "" },
                    { 45, "", "", "", "", 0, 3, 0, "" },
                    { 46, "", "", "", "", 0, 3, 0, "" },
                    { 47, "", "", "", "", 0, 3, 0, "" },
                    { 48, "", "", "", "", 0, 3, 0, "" },
                    { 49, "", "", "", "", 0, 3, 0, "" },
                    { 50, "", "", "", "", 0, 3, 0, "" },
                    { 51, "", "", "", "", 0, 3, 0, "" },
                    { 52, "", "", "", "", 0, 3, 0, "" },
                    { 53, "", "", "", "", 0, 3, 0, "" },
                    { 54, "", "", "", "", 0, 3, 0, "" },
                    { 55, "", "", "", "", 0, 3, 0, "" },
                    { 56, "", "", "", "", 0, 3, 0, "" },
                    { 57, "", "", "", "", 0, 3, 0, "" },
                    { 58, "", "", "", "", 0, 3, 0, "" },
                    { 59, "", "", "", "", 0, 3, 0, "" },
                    { 60, "", "", "", "", 0, 3, 0, "" },
                    { 61, "", "", "", "", 0, 4, 0, "" },
                    { 62, "", "", "", "", 0, 4, 0, "" },
                    { 63, "", "", "", "", 0, 4, 0, "" },
                    { 64, "", "", "", "", 0, 4, 0, "" },
                    { 65, "", "", "", "", 0, 4, 0, "" },
                    { 66, "", "", "", "", 0, 4, 0, "" },
                    { 67, "", "", "", "", 0, 4, 0, "" },
                    { 68, "", "", "", "", 0, 4, 0, "" },
                    { 69, "", "", "", "", 0, 4, 0, "" },
                    { 70, "", "", "", "", 0, 4, 0, "" },
                    { 71, "", "", "", "", 0, 4, 0, "" },
                    { 72, "", "", "", "", 0, 4, 0, "" },
                    { 73, "", "", "", "", 0, 4, 0, "" },
                    { 74, "", "", "", "", 0, 4, 0, "" },
                    { 75, "", "", "", "", 0, 4, 0, "" },
                    { 76, "", "", "", "", 0, 4, 0, "" },
                    { 77, "", "", "", "", 0, 4, 0, "" },
                    { 78, "", "", "", "", 0, 4, 0, "" },
                    { 79, "", "", "", "", 0, 4, 0, "" },
                    { 80, "", "", "", "", 0, 4, 0, "" },
                    { 81, "", "", "", "", 0, 5, 0, "" },
                    { 82, "", "", "", "", 0, 5, 0, "" },
                    { 83, "", "", "", "", 0, 5, 0, "" },
                    { 84, "", "", "", "", 0, 5, 0, "" },
                    { 85, "", "", "", "", 0, 5, 0, "" },
                    { 86, "", "", "", "", 0, 5, 0, "" },
                    { 87, "", "", "", "", 0, 5, 0, "" },
                    { 88, "", "", "", "", 0, 5, 0, "" },
                    { 89, "", "", "", "", 0, 5, 0, "" },
                    { 90, "", "", "", "", 0, 5, 0, "" },
                    { 91, "", "", "", "", 0, 5, 0, "" },
                    { 92, "", "", "", "", 0, 5, 0, "" },
                    { 93, "", "", "", "", 0, 5, 0, "" },
                    { 94, "", "", "", "", 0, 5, 0, "" },
                    { 95, "", "", "", "", 0, 5, 0, "" },
                    { 96, "", "", "", "", 0, 5, 0, "" },
                    { 97, "", "", "", "", 0, 5, 0, "" },
                    { 98, "", "", "", "", 0, 5, 0, "" },
                    { 99, "", "", "", "", 0, 5, 0, "" },
                    { 100, "", "", "", "", 0, 5, 0, "" },
                    { 101, "", "", "", "", 0, 6, 0, "" },
                    { 102, "", "", "", "", 0, 6, 0, "" },
                    { 103, "", "", "", "", 0, 6, 0, "" },
                    { 104, "", "", "", "", 0, 6, 0, "" },
                    { 105, "", "", "", "", 0, 6, 0, "" },
                    { 106, "", "", "", "", 0, 6, 0, "" },
                    { 107, "", "", "", "", 0, 6, 0, "" },
                    { 108, "", "", "", "", 0, 6, 0, "" },
                    { 109, "", "", "", "", 0, 6, 0, "" },
                    { 110, "", "", "", "", 0, 6, 0, "" },
                    { 111, "", "", "", "", 0, 6, 0, "" },
                    { 112, "", "", "", "", 0, 6, 0, "" },
                    { 113, "", "", "", "", 0, 6, 0, "" },
                    { 114, "", "", "", "", 0, 6, 0, "" },
                    { 115, "", "", "", "", 0, 6, 0, "" },
                    { 116, "", "", "", "", 0, 6, 0, "" },
                    { 117, "", "", "", "", 0, 6, 0, "" },
                    { 118, "", "", "", "", 0, 6, 0, "" },
                    { 119, "", "", "", "", 0, 6, 0, "" },
                    { 120, "", "", "", "", 0, 6, 0, "" }
                });

            migrationBuilder.InsertData(
                table: "Docs",
                columns: new[] { "Id", "CourseId", "DocName", "LessonId" },
                values: new object[,]
                {
                    { 1, 1, "", 1 },
                    { 2, 1, "", 2 },
                    { 3, 1, "", 3 },
                    { 4, 1, "", 4 },
                    { 5, 1, "", 5 },
                    { 6, 1, "", 6 },
                    { 7, 2, "", 7 },
                    { 8, 2, "", 8 },
                    { 9, 2, "", 9 },
                    { 10, 2, "", 10 },
                    { 11, 2, "", 11 },
                    { 12, 2, "", 12 },
                    { 13, 3, "", 13 },
                    { 14, 3, "", 14 },
                    { 15, 3, "", 15 },
                    { 16, 3, "", 16 },
                    { 17, 3, "", 17 },
                    { 18, 3, "", 18 },
                    { 19, 4, "", 19 },
                    { 20, 4, "", 20 },
                    { 21, 4, "", 21 },
                    { 22, 4, "", 22 },
                    { 23, 4, "", 23 },
                    { 24, 4, "", 24 },
                    { 25, 5, "", 25 },
                    { 26, 5, "", 26 },
                    { 27, 5, "", 27 },
                    { 28, 5, "", 28 },
                    { 29, 5, "", 29 },
                    { 30, 5, "", 30 },
                    { 31, 6, "", 31 },
                    { 32, 6, "", 32 },
                    { 33, 6, "", 33 },
                    { 34, 6, "", 34 },
                    { 35, 6, "", 35 },
                    { 36, 6, "", 36 }
                });

            migrationBuilder.InsertData(
                table: "Homeworks",
                columns: new[] { "Id", "Content", "CourseId", "Deadline", "LessonId", "Title" },
                values: new object[,]
                {
                    { 1, "", 1, new DateOnly(2024, 6, 15), 1, "Домашнее задание" },
                    { 2, "", 1, new DateOnly(2024, 6, 15), 2, "Домашнее задание" },
                    { 3, "", 1, new DateOnly(2024, 6, 15), 3, "Домашнее задание" },
                    { 4, "", 1, new DateOnly(2024, 6, 15), 4, "Домашнее задание" },
                    { 5, "", 1, new DateOnly(2024, 6, 15), 5, "Домашнее задание" },
                    { 6, "", 1, new DateOnly(2024, 6, 15), 6, "Домашнее задание" },
                    { 7, "", 2, new DateOnly(2024, 6, 15), 7, "Домашнее задание" },
                    { 8, "", 2, new DateOnly(2024, 6, 15), 8, "Домашнее задание" },
                    { 9, "", 2, new DateOnly(2024, 6, 15), 9, "Домашнее задание" },
                    { 10, "", 2, new DateOnly(2024, 6, 15), 10, "Домашнее задание" },
                    { 11, "", 2, new DateOnly(2024, 6, 15), 11, "Домашнее задание" },
                    { 12, "", 2, new DateOnly(2024, 6, 15), 12, "Домашнее задание" },
                    { 13, "", 3, new DateOnly(2024, 6, 15), 13, "Домашнее задание" },
                    { 14, "", 3, new DateOnly(2024, 6, 15), 14, "Домашнее задание" },
                    { 15, "", 3, new DateOnly(2024, 6, 15), 15, "Домашнее задание" },
                    { 16, "", 3, new DateOnly(2024, 6, 15), 16, "Домашнее задание" },
                    { 17, "", 3, new DateOnly(2024, 6, 15), 17, "Домашнее задание" },
                    { 18, "", 3, new DateOnly(2024, 6, 15), 18, "Домашнее задание" },
                    { 19, "", 4, new DateOnly(2024, 6, 15), 19, "Домашнее задание" },
                    { 20, "", 4, new DateOnly(2024, 6, 15), 20, "Домашнее задание" },
                    { 21, "", 4, new DateOnly(2024, 6, 15), 21, "Домашнее задание" },
                    { 22, "", 4, new DateOnly(2024, 6, 15), 22, "Домашнее задание" },
                    { 23, "", 4, new DateOnly(2024, 6, 15), 23, "Домашнее задание" },
                    { 24, "", 4, new DateOnly(2024, 6, 15), 24, "Домашнее задание" },
                    { 25, "", 5, new DateOnly(2024, 6, 15), 25, "Домашнее задание" },
                    { 26, "", 5, new DateOnly(2024, 6, 15), 26, "Домашнее задание" },
                    { 27, "", 5, new DateOnly(2024, 6, 15), 27, "Домашнее задание" },
                    { 28, "", 5, new DateOnly(2024, 6, 15), 28, "Домашнее задание" },
                    { 29, "", 5, new DateOnly(2024, 6, 15), 29, "Домашнее задание" },
                    { 30, "", 5, new DateOnly(2024, 6, 15), 30, "Домашнее задание" },
                    { 31, "", 6, new DateOnly(2024, 6, 15), 31, "Домашнее задание" },
                    { 32, "", 6, new DateOnly(2024, 6, 15), 32, "Домашнее задание" },
                    { 33, "", 6, new DateOnly(2024, 6, 15), 33, "Домашнее задание" },
                    { 34, "", 6, new DateOnly(2024, 6, 15), 34, "Домашнее задание" },
                    { 35, "", 6, new DateOnly(2024, 6, 15), 35, "Домашнее задание" },
                    { 36, "", 6, new DateOnly(2024, 6, 15), 36, "Домашнее задание" }
                });

            migrationBuilder.InsertData(
                table: "Videos",
                columns: new[] { "Id", "CourseId", "LessonId", "VideoName" },
                values: new object[,]
                {
                    { 1, 1, 1, "" },
                    { 2, 1, 2, "" },
                    { 3, 1, 3, "" },
                    { 4, 1, 4, "" },
                    { 5, 1, 5, "" },
                    { 6, 1, 6, "" },
                    { 7, 2, 7, "" },
                    { 8, 2, 8, "" },
                    { 9, 2, 9, "" },
                    { 10, 2, 10, "" },
                    { 11, 2, 11, "" },
                    { 12, 2, 12, "" },
                    { 13, 3, 13, "" },
                    { 14, 3, 14, "" },
                    { 15, 3, 15, "" },
                    { 16, 3, 16, "" },
                    { 17, 3, 17, "" },
                    { 18, 3, 18, "" },
                    { 19, 4, 19, "" },
                    { 20, 4, 20, "" },
                    { 21, 4, 21, "" },
                    { 22, 4, 22, "" },
                    { 23, 4, 23, "" },
                    { 24, 4, 24, "" },
                    { 25, 5, 25, "" },
                    { 26, 5, 26, "" },
                    { 27, 5, 27, "" },
                    { 28, 5, 28, "" },
                    { 29, 5, 29, "" },
                    { 30, 5, 30, "" },
                    { 31, 6, 31, "" },
                    { 32, 6, 32, "" },
                    { 33, 6, 33, "" },
                    { 34, 6, 34, "" },
                    { 35, 6, 35, "" },
                    { 36, 6, 36, "" }
                });

            migrationBuilder.CreateIndex(
                name: "IX_Docs_CourseId",
                table: "Docs",
                column: "CourseId");

            migrationBuilder.CreateIndex(
                name: "IX_Docs_LessonId",
                table: "Docs",
                column: "LessonId");

            migrationBuilder.CreateIndex(
                name: "IX_Homeworks_CourseId",
                table: "Homeworks",
                column: "CourseId");

            migrationBuilder.CreateIndex(
                name: "IX_Homeworks_LessonId",
                table: "Homeworks",
                column: "LessonId");

            migrationBuilder.CreateIndex(
                name: "IX_Lessons_CourseId",
                table: "Lessons",
                column: "CourseId");

            migrationBuilder.CreateIndex(
                name: "IX_Materials_CourseId",
                table: "Materials",
                column: "CourseId");

            migrationBuilder.CreateIndex(
                name: "IX_Materials_HomeworkId",
                table: "Materials",
                column: "HomeworkId",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Materials_LessonId",
                table: "Materials",
                column: "LessonId");

            migrationBuilder.CreateIndex(
                name: "IX_Tests_CourseId",
                table: "Tests",
                column: "CourseId");

            migrationBuilder.CreateIndex(
                name: "IX_UserCourses_CourseId",
                table: "UserCourses",
                column: "CourseId");

            migrationBuilder.CreateIndex(
                name: "IX_Videos_CourseId",
                table: "Videos",
                column: "CourseId");

            migrationBuilder.CreateIndex(
                name: "IX_Videos_LessonId",
                table: "Videos",
                column: "LessonId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Docs");

            migrationBuilder.DropTable(
                name: "Materials");

            migrationBuilder.DropTable(
                name: "Tests");

            migrationBuilder.DropTable(
                name: "UserCourses");

            migrationBuilder.DropTable(
                name: "Videos");

            migrationBuilder.DropTable(
                name: "Homeworks");

            migrationBuilder.DropTable(
                name: "Users");

            migrationBuilder.DropTable(
                name: "Lessons");

            migrationBuilder.DropTable(
                name: "Courses");
        }
    }
}
